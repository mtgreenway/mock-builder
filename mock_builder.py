#!/usr/bin/env python
#  Copyright 2013 Open Cloud Consortium
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#

import argparse
import os
import shutil
import subprocess
import tempfile


def create_mock(client, server):
    ''' create mock functions from client and server data '''
    return "\n".join([
        create_def(client.split(" HTTP")[0]),
        "    return ('''%s''', %s, %s)" % (
            response_data(server),
            status_code(server),
            headers(server))])


def response_data(server):
    ''' Extract the response data from the server text '''
    return server.split("\r\n\r\n")[1].replace("\r", "")


def status_code(server):
    ''' Extract the status code from the server text '''
    return server.split(" ")[1]


def headers(server):
    ''' Extract the response headers from the server text '''
    items = []
    for line in server.split("\r\n\r\n")[0].split("\r\n")[1:]:
        parts = line.split(": ")
        items.append('"%s": "%s"' % (parts[0], ": ".join(parts[1:])))
    return "{%s}" % ", ".join(items)


def params_from_path(path):
    ''' if there are things in the path that need to be parameters such as
    uuids or specified unique names to search for like usernames make those
    params '''

    return path, []



def create_def(method_path):
    ''' using the first part of the HTTP request to generate the function
    signature '''
    method, path = method_path.split(" ")
    path, parameters = params_from_path(path)
    dec = '@app.route("%s", methods=["%s"])' % (path, method)
    func_name = method.lower() + path.replace('/', '_')
    param_string = ""
    for i in parameters:
        param_string += i + ", "
    sig = 'def %s(%s):' % (func_name, param_string[:-2])
    return '\n'.join([dec, sig])


def main():

    parser = argparse.ArgumentParser(
            description="Generates HTTP mock from command")
    parser.add_argument("command", type=str)
    #parser.add_argument("cmd_args", metavar="C", type=str,
    #        nargs=argparse.REMAINDER)
    parser.add_argument("-p", dest="port", required=True, type=int)
    parser.add_argument("-i", dest="iface", default="any", type=str)

    args = parser.parse_args()
    iface = args.iface
    port = "%s" % args.port
    cmd = "%s 2>1 > /dev/null" % args.command

    tcpflow = "/usr/bin/tcpflow"
    tcpflow_command = [tcpflow, "-i", iface, "port", port]

    new_dir = tempfile.mkdtemp()
    os.chdir(new_dir)

    dump_proc = subprocess.Popen(tcpflow_command)

    run_proc = subprocess.Popen([cmd], shell=True)
    run_proc.wait()

    dump_proc.kill()

    client_server = []
    for f in os.listdir(os.getcwd()):
        if f.endswith("00000"[len(port):] + port):
            rev = f.split('-')
            rev.reverse()
            server_file = '-'.join(rev)
            client_server.append((open(f), open(server_file)))

    mock_functions = [
        "#!/usr/bin/env python",
        "# Generated by mock-builder",
        "from flask import Flask, request",
        "app = Flask(__name__)"
    ]

    for client, server in client_server:
        c_data = client.read()
        client.close()
        s_data = server.read()
        server.close()
        mock_functions.append(create_mock(c_data, s_data))

    mock_functions.append(
        'if __name__ == "__main__": app.run(host="127.1", debug=True, port=%s)' % port)

    print "\n\n".join(mock_functions)


    shutil.rmtree(new_dir)

if __name__ == '__main__':
    main()
